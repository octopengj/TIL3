## 4. 실행 콘텍스트

### 4.1. 실행 콘텍스트, 실행 콘텍스트 상태 컴포넌트

#### 4.1.1. 실행 콘텍스트

- Execution Context
  
  - 함수가 실행되는 영역, 묶음
  
  - 함수 코드를 실행하고 실행 결과를 저장
  
  - 스펙상의 사양

- book으로 함수를 호출하면
  
  - 엔진은 실행 콘텍스트를 생성하고
  
  - 실행 콘텍스트 안으로 이동

- 실행 콘텍스트 실행 단계
  
  - 준비 단계, 초기화 단계, 코드 실행 단계
  
  ```javascript
  function book(title){
      var bookTitle = title;
  };
  book("책");
  ```

- 실행 콘텍스트 생성 시점
  
  - 실행 가능한 코드를 만났을 때

- 실행 가능한 코드 유형
  
  - 함수 코드, 글로벌 코드, eval  코드

- 코드 유형을 분리한 이유
  
  - 실행 콘텍스트에서 처리 방법과 실행 환경이 다르기 때문
  
  - 함수 코드: 렉시컬 환경
  
  - 글로벌 코드: 글로벌 환경
  
  - eval코드: 동적 환경

#### 4.1.2. 실행 콘텍스트 상태 컴포넌트

- 실행 콘텍스트 상태를 위한 오브젝트
  
  - 실행 콘텍스트 안에 생성

- 상태 컴포넌트 유형
  
  - 렉시컬 환경 컴포넌트(LEC) Lexical Environment Component
  
  - 변수 환경 컴포넌트(VEC) Variable Environment Component
  
  - this 바인딩 컴포넌트(TBC) This Binding Component
  
  > 실행 콘텍스트(EC): {
  > 
  >     렉시컬 환경 컴포넌트(LEC): { },
  > 
  >     변수 환경 컴포넌트(VEC): { },
  > 
  >     this 바인딩 컴포넌트(TBC): { }
  > 
  > }

### 4.2. 렉시컬 환경 컴포넌트, 렉시컬 환경 컴포넌트 구성/설정, 외부 렉시컬 환경 참조, 변수 환경 컴포넌트

#### 4.2.1. 렉시컬 환경 컴포넌트

- 함수와 변수의 식별자 해결을 위한 환경 설정

- 함수 초기화 단계에서 해석한
  
  - 함수와 변수를 {name: value} 형태로 저장
  
  - 이름으로 함수와 변수를 검색할 수 있게 됨

- 함수 밖의 함수와 변수 참조 환경 설정
  
  - 함수 밖의 함수와 변수를 사용할 수 있게 됨

#### 4.2.2. 렉시컬 환경 컴포넌트 구성/설정

> 실행 콘텍스트(EC): {
> 
>     렉시컬 환경 컴포넌트(LEC): {
> 
>         환경 레코드(ER): {
> 
>         },
> 
>         외부 렉시컬 환경 참조(OLER):{
> 
>         }
> 
>     }
> 
> }

구성

- 렉시컬 환경 컴포넌트 생성
  
  - function, with, try-catch에서 생성

- 컴포넌트 구성
  
  - 환경 레코드
    
    ER: Environment Record
  
  - 외부 렉시컬 환경 참조
    
    OLER: Outer Lexical Environment Reference

설정

- 환경 레코드에
  
  - 함수 안의 함수와 변수를 기록

- 외부 렉시컬 환경 참조에
  
  - function 오브젝트의 내부 프로퍼티에 [[Scope]]를 설정

- 따라서 함수 안과 밖의 함수와 변수를 사용할 수 있게 됨

#### 4.2.3. 외부 렉시컬 환경 참조

- 스코프와 실행중인 함수가 Context 형태이므로
  
  - 스코프의 변수와 함수를 별도의 처리 없이 즉시 사용할 수 있음

- 실행 콘텍스트에서
  
  - 함수 안과 밖의 함수, 변수를 사용할 수 있으므로
  
  - 함수와 변수를 찾기 위해 실행 콘텍스트를 벗어 나지 않아도 됨

#### 4.2.4. 변수 환경 컴포넌트

> 실행 콘텍스트(EC): {
> 
>     렉시컬 환경 컴포넌트(LEC): { },
> 
>     변수 환경 컴포넌트(VEC): { },
> 
>     this 바인딩 컴포넌트(TBC): { }
> 
> }

- 실행 콘텍스트 초기화 단계에서
  
  - 렉시컬 환경 컴포넌트와 같게 설정
  
  - 이유는?
    
    - 초깃값을 복원할 때 사용하기 위한 것

- 함수 코드가 실행되면
  
  - 실행 결과를 렉시컬 환경 컴포넌트에 설정
  
  - 초깃값이 변하게 되므로 이를 유지하기 위한 것

### 4.3. 실행 콘텍스트 실행 과정

#### 4.3.1. 실행 콘텍스트 실행 과정

```javascript
var base = 200;
function getPoint(bonus){
    var point = 100;
    return point + base + bonus;
};
console.log(getPoint(50)); // 350
```

1. getPoint 오브젝트의 [[Scope]]에 글로벌 오브젝트 설정

2. 마지막 줄에서 getPoint( ) 함수를 호출하면

3. 엔진은 실행 콘텍스트를 생성하고 실행 콘텍스트 안으로 이동
   
   --- 준비단계---

4. 컴포넌트를 생성하여 실행 콘텍스트에 첨부
   
   - 렉시컬 환경 컴포넌트
   
   - 변수 환경 컴포넌트
   
   - this 바인딩 컴포넌트

5. 환경 레코드를 생성하여 렉시컬 환경 컴포넌트에 첨부
   
   - 함수 안의 함수, 변수를 바인딩
   
   > 실행 콘텍스트: {
   > 
   >     렉시컬 환경 컴포넌트 : {
   > 
   >         환경 레코드: { }
   > 
   >     },
   > 
   >     변수 환경 컴포넌트: { },
   > 
   >     this 바인딩 컴포넌트: { }
   > 
   > }

6. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부하고
   
   - function 오브젝트의 [[Scope]]를 설정
   
   > 실행 콘텍스트: {
   > 
   >     렉시컬 환경 컴포넌트: {
   > 
   >         환경 레코드: { },
   > 
   >         외부 렉시컬 환경 참조: {
   > 
   >             base: 200
   > 
   >         }
   > 
   >     },
   > 
   >     변수 환경 컴포넌트: { },
   > 
   >     this 바인딩 컴포넌트: { }
   > 
   > }
   
   --- 초기화 단계---

7. 호출한 함수의 파라미터 값을
   
   - 호출된 함수의 파라미터 이름에 매핑
   
   - 환경 레코드에 작성

8. 함수 선언문을 function 오브젝트로 생성

9. 함수 표현식과 변수에 초깃값 설정

10. 여기까지는 외부에 실행 상태를 제공하지 않는다
    
    > 실행 콘텍스트: {
    > 
    >     렉시컬 환경 컴포넌트: { 
    > 
    >         환경 레코드: {
    > 
    >             bonus: 50,
    > 
    >             point: undefined
    > 
    >         },
    > 
    >         외부 렉시컬 환경 참조: {
    > 
    >             base: 200
    > 
    >         }
    > 
    >     },
    > 
    >     변수 환경 컴포넌트: { },
    > 
    >     this 바인딩 컴포넌트: { }
    > 
    > }
    
    --- 실행 단계 ---

11. 함수 안의 코드를 실행
    
    - var point = 100;

12. 실행 콘텍스트 안에서 관련된 함수와 변수를 사용할 수 있음

### 4.4. 환경 레코드, 구성, 글로벌 환경

#### 4.4.1. 환경 레코드, 구성

> 실행 콘텍스트: {
> 
>     렉시컬 환경 컴포넌트: {
> 
>         환경 레코드: {
> 
>             선언적 환경 레코드: {
> 
>                 point: 123
> 
>             },
> 
>             오브젝트 환경 레코드: { }
> 
>         },
> 
>         외부 렉시컬 환경 참조: { }
> 
>     },
> 
>     변수 환경 컴포넌트: { },
> 
>     this 바인딩 컴포넌트: { }
> 
> }

- 환경 레코드를 구분하는 이유
  
  - 기록 대상에 따라 다르기 때문

- 선언적 환경 레코드
  
  - DER: Declarative Environment Record
  
  - function, 변수, catch 문에서 사용
  
  - 위에서 환경 레코드에 설정한다고 했는데 실제로는 이곳에 설정

- 오브젝트 환경 레코드
  
  - OER: Object Environment Record
  
  - 글로벌 함수와 변수, with 문에서 사용
  
  - 정적이 아니라 동적이기 때문

#### 4.4.2. 글로벌 환경

> 실행 컨텍스트: {
> 
>     글로벌 환경: {
> 
>         환경 레코드: {
> 
>             오브젝트 환경 레코드: 글로벌 오브젝트
> 
>         },
> 
>         외부 렉시컬 환경 참조: null
> 
>     }
> 
> }

- GE: Global Environment
  
  - 글로벌 오브젝트에서 사용
  
  - 렉시컬 환경 컴포넌트와 형태 같음

- 동적으로 함수와 변수 바인딩
  
  - 함수에서 var 키워드를 사용하지 않고 변수를 선언하면
    
    글로벌 오브젝트에 설정되기 때문
  
  - 이런 이유로 오브젝트 환경 레코드 사용

- 외부 렉시컬 환경 참조 값은 null ( 글로벌 오브젝트는 어디에도 속하지 않는다)

### 4.5. this 바인딩 컴포넌트

#### 4.5.1. this 바인딩 컴포넌트

- 목적
  
  - this로 함수를 호출한 오브젝트의 프로퍼티에 접근

- 접근 메커니즘
  
  - obj.book( ) 형태에서
  
  - this로 obj를 참조할 수 있도록
  
  - this 바인딩 컴포넌트에 obj 참조를 설정

- obj의 프로퍼티가 변경되면 동적으로 참조
  
  - 설정이 아닌 참조이기 때문

```javascript
var obj = {point: 100};
obj.getPoint = function(){
    return this.point;
};
obj.getPoint();
```

> 실행 콘텍스트: {
> 
>     렉시컬 환경 컴포넌트: {
> 
>         환경 레코드: {
> 
>             선언적 환경 레코드: { },
> 
>             오브젝트 환경 레코드: { }
> 
>         },
> 
>         외부 렉시컬 환경 참조: { }
> 
>     },
> 
>     변수 환경 컴포넌트: { },
> 
>     this 바인딩 컴포넌트: {
> 
>         point: 100,
> 
>         getPoint: function( ){ }
> 
>     }
> 
> }

--- 준비단계 ---

1. 마지막 줄에서 obj.getPoint( ) 함수 호출

2. 실행 콘텍스트 생성

3. 3개의 컴포넌트 생성
   
   - 렉시컬 환경 컴포넌트, 변수 환경 컴포넌트, this 바인딩 컴포넌트

4. this 바인딩 컴포넌트에
   
   - getPoint( )에서 this로 obj의 프로퍼티를 사용할 수 있도록 바인딩

--- 초기화 단계 ---

5. 파라미터, 함수 선언문, 변수 선언 없음

--- 실행 단계 ---

6. return this.point; 실행

7. this 바인딩 컴포넌트에서 point 검색
   
   - getPoint( ) 함수를 호출한 오브젝트가
   
   - this 바인딩 컴포넌트에 설정(참조)된 상태

8. this 바인딩 컴포넌트에 point 프로퍼티가 있으므로 100을 반환

### 4.6. 호출스택(call stack)

#### 4.6.1. 호출스택

- call stack
  
  - 실행 콘텍스트의 논리적 구조

- First In Last Out 순서
  
  - 함수가 호출되면 스택의 가장 위에 실행 콘텍스트가 위치하게 됨
  
  - 다시 함수 안에서 함수를 호출하면 호출된 함수의 실행 콘텍스트가 스택의 가장 위에 놓이게 됨
  
  - 함수가 종료되면 스택에서 빠져 나옴 FILO 순서대로

- 가장 아래는 글로벌 오브젝트의 함수가 위치

- 자바스크립트는 싱글쓰레드이기 때문에
  
  ```javascript
  function one(){
      two();
      console.log(1);
  };
  function two(){
      three();
      console.log(2);
  }
  function three(){
      console.log(3);
  }
  
  one();
  // 3
  // 2
  // 1
  ```

### 4.7. 파라미터 매핑, 함수 호출, 파라미터 값 매핑, 파라미터 이름에 값 매핑 방법

#### 4.7.1. 함수 호출

- 함수가 호출되면 3개의 파라미터 값을 실행 콘텍스트로 넘겨 줌
  
  - 함수를 호출한 오브젝트
  
  - 함수 코드
  
  - 호출한 함수의 파라미터 값

- 함수를 호출한 오브젝트를
  
  - this 바인딩 컴포넌트에 설정하여 this로 참조

- 함수 코드
  
  - function 오브젝트의 [[Code]]에 설정되어 있음

- 호출한 함수의 파라미터 값
  
  - 호출됨 함수의 Argument 오브젝트에 설정

#### 4.7.2. 파라미터 값 매핑

- 파라미터 값 매핑
  
  - 호출한 함수에서 넘겨 준 파라미터 값을
    
    호출된 함수의 파라미터 작성 순서에 맞추어 값을 매핑하는 것

- 엔진 처리 관점
  
  - 실행 콘텍스트로 넘겨 준 파라미터 값과
    
    function 오브젝트의 [[FormalParameters]]에 작성된 이름에 값을 매핑하고
    
    결과를 선언적 환경 레코드에 설정하는 것

#### 4.7.3. 파라미터 이름에 값 매핑 방법

```javascript
var obj = {};
obj.getTotal = function(one, two){
    return one + two
};
console.log(obj.getTotal(10,20,30)); // 30
```

1. getTotal 오브젝트의 [[FormalParameters]]에서
   
   - 호출된 함수의 파라미터 이름을 구함
   
   - name은 ["one","two"]형태
   
   - [[FormalParameters]]는 function 오브젝트를 생성할 때 설정함

2. name 배열을 하나씩 읽음

3. 실행 콘텍스트로 넘겨준 파라미터 값에서 index 번째의 값을 구함
   
   - index에 값이 없으면 undefined를 반환

4. name의 파라미터 이름과 3번에서 구한 값을
   
   - 선언적 환경 레코드에 {one:10, two:20} 형태로 설정
   
   - 같은 이름이 있으면 값이 대체됨

5. name을 전부 읽을 때까지 2번에서 4번까지 반복

### 4.8. 파라미터 값 할당 기준

#### 4.8.1. 파라미터 값 할당 기준

```javascript
var obj = {}
obj.getTotal = function(one, two){
    var one;
    console.log(one + two); // 30
    two = 50;
    console.log("two:" + two); // two: 50
};
obj.getTotal(10,20);
```

1. obj.getTotal(10,20) 함수가 호출되면
   
   - 파라미터 값을 실행 콘텍스트로 넘겨줌

2. 파라미터 이름에 값을 매핑하여
   
   - 선언적 환경 레코드에 설정
   
   - {one:10, two:20}

3. var one;
   
   - 선언적 환경 레코드에 one의 존재를 체크
   
   - 파라미터 이름을 설정하였으므로 존재하며
   
   - one을 기록하지 않음

4. two=50;
   
   - 선언적 환경 레코드에서 two의 존재를 체크
   
   - 파라미터 이름을 설정하였으므로 존재하며
   
   - two를 기록하지 않음

5. 함수에 초기화할 코드가 없음
   
   - 첫 번째 줄로 이동하여 함수 코드를 실행

--- 실행 단계 ---

6. 선언적 환경 레코드는
   
   - {one:10, two:20} 상태

7. var one;
   
   - 변수 선언이므로 처리하지 않음

8. console.log(one+two);
   
   - 선언적 환경 레코드에서 one과 two의 값을 구함
   
   - 10과 20의 결과인 30이 실행 결과에 출력

9. two = 50;
   
   - 값을 할당하는 코드이며 실행 단계이므로 
     
     선언적 환경 레코드의 two에 50을 할당하며
     
     {two:30}이 {two:50}으로 변경됨

10. console.log("two:" + two);
    
    - 선언적 환경 레코드에서 two의 값을 구함
    
    - 실행결과에 two:50이 출력됨
