# 1. JavaScript Beginner

## 1. 자바스크립트

### 1.1. 자바스크립트로 할 수 있는 것

- 예를 들어 "가입하기" 버튼 클릭을 인식할 때 DOM과 JavaScript를 사용

- 이메일, 비밀번호 입력 여부 체크를 할 때 DOM과  JavaScript를 사용

- 브라우저에서 이메일 등록 여부 체크 불가 -> 입력한 값을 서버로 전송할 때 DOM과 JavaScript를 사용

- 서버 프로그램에서 이메일 체크, 결과 전송 -> JavaScript,  Java등

- 브라우저에서 결과 수신을 할 때 JavaScript를 사용

- 결과에 따른 처리를 할 때 HTML, CSS, DOM, JavaScript를 사용

Ajax가 나오기 전까지만해서 서버에서 이 모든것을 관리하고 처리하고 브라우저는 단지 출력만 했었다.

Ajax에서 비동기처리방식을 제공하게 되는데 이 방법으로 분산처리를 구현가능하게 했다.

### 1.2. 자바스크립트 키워드

- 기술융합
  
  - HTML, CSS, DOM, API등을 연결

- 디바이스 통합

- 통합과 융합을 자바스크립트로 컨트롤

- 브라우저, 클라이언트, 서버, Node.js까지 단일 언어(JavaScript)로 처리 - > 풀스택

자바스크립트의 궁극적인 목적은 사용자이다.

## 

## 2. 기본 문법

### 2.1. 문장 Statement

- 자바스크립트의 실행단위

- 세미콜론까지 하나의 문장

### 2.2. 변수

- 값을 저장하는 영역

- 변수를 선언하고 변수에 값을 할당하여 사용한다.

- 의미를 부여하여 변수 이름 작명 -> 시맨틱

### 2.3. 주석

- 자바스크립트 코드로 인식하지 않는다.

- 한줄 주석 `//`

- 블록주석 `/** **/`

### 2.4. console.log()

- 소괄호 안에 작성된 값을 브라우처 console창에 출력

### 2.5 정수, 실수, 숫자처리

- 정수
  
  - 소수가 없는 숫자

- 실수
  
  - 소수를 가진 숫자

- 자바스크립트는 정수, 실수를 구분하지 않음(ES5기준), ES6에서 정수, 실수 구분 

- 숫자처리
  
  - 64비트 부동소수점 처리
  
  - 부동소수점 처리 ->123을 123.0으로 처리

### 2.6. 상수, 진수

- 상수
  
  - 변경할 수 없는 값
  
  - 코딩 관례로 영문 대문자 사용  예) var ONE = 1; 하여 시맨틱 선언
  
  - 자바스크립트가 제공한느 상숫값은 변경 불가
    
    - MAX_VALUE, MIN_VALUE 등

- 진수
  
  - 10진수
    
    - 123
  
  - 16진수
    
    - 0xff : 255
    
    - 1번째 숫자 0 작성
    
    - 2번째 영문자 x 작성
    
    - 3번째 이후: 0 ~ f 작성
    
    - 대소문자 구분하지 않음
    
    - a:10, b:11, c:12, d:13, e:14, f:15
  
  - 8진수 
    
    - ES3에서 폐지, ES6에서 재정의
  
  - 2진수
    
    - ES6에서 특별한 방법 제공
    
    - 머신러닝, 딥러닝에서 사용 

### 2.7. 데이터타입

- 데이터 타입을 자료형이라고도 부름

- 데이터는 타입을 가짐
  
  - 자바스크립트는 데이터를 기준으로 타입을 결정
  
  - 타입을 먼저 선언하고 타입에 맞는 데이터를 할당하지 않음

- Undefined, Null, Boolean, String, Number, Object

### 2.8. Number 타입, String 타입

- Number 
  
  - 부호를 가진 값
  
  - 넘버 타입의 특수한 값
    
    - NaN: Not a Number
      
      - 숫자가 아닌 것을 연산할 때 프로그램을 죽이지 않고 나타내는 값
    
    - Infinity: 양수 무한대
    
    - -Infinity: 음수 무한대

- String
  
  - 값을 `""`, `''` 사이에 작성

### 2.9. Undefined, Null 타입

- Undefined
  
  - 변수에 값을 할당하지 않은 것을 나타내는 시맨틱
  
  - 자바스크립트가 암묵적으로 undefined를 할당함
  
  - 변수에 undefined 할당 가능

- Null
  
  - null을 할당해야 값이 null이 됨
  
  - 의도적으로 값을 할당한 것으로 코드를 수행한 것이 됨

### 2.10. Boolean, Object 타입

- Boolean
  
  - true, false

- Object
  
  - `{key: value}` 형태
  
  - 프로퍼티
    
    - key와 value 하나를 지칭
  
  - Object는 프로퍼티 집합

## 

## 3. 연산자(Operator)

### 3.1. 연산자, 표현식

- 연산의 사전적 의미
  
  - 규칙에 따라 계산하여 값을 구함

- 연산자 형태
  
  - `+`, `-`, `*`, `/`, `%`
  
  - `>`, `>=`, `<`, `<=`
  
  - `==`, `!=`, `===`, `!==`
  
  - 콤마, typeof, delete, void
  
  - instanceof, in, new 등

- 표현식
  
  - 결과가 있는 식, 값이 있는 식
  
  - 표현식을 평가한다고 한다.
  
  - 표현식을 평가하면 결과가 반환되며 이를 평가 결과라고 한다.

### 3.2. 할당 연산자, 해석

- 단일 할당 연산자
  
  - `=`

- 복합 할당 연산자
  
  - `+=`, `-=`, `*=`, `/=`, `%=`
  
  - `<<=`, `>>=`
  
  - 먼저 =앞을 실행한후 =를 실행

- 해석
  
  - 자바스크립트 코드를 기계어로 바꾸는 것 => Compile

### 3.3. 산술 연산자

- `+` 양쪽의 표현식을 평가

- 한쪽이라도 숫자가 아니면 연결을 한다.
  
  ```javascript
  var three = "3";
  var value = 1 + three;
  console.log(value); // 13
  console.log(typeof value); string
  ```
  
  3을 숫자 3으로 변경하여 값을 평가한것이 아니라 number 1과 string 3을 연결한 것
  
  그 결과, 타입을 확인하면 string가 된다.
  
  자바스크립트는 하나의 코드에 의한 에러때문에 전체가 깨지지 않게 하려는 경향이 있어서 이러한 결과가 나온다.

- `-`, `*`, `/` 의 경우 타입이 string이지만 값이 number이면 숫자로 변환하여 연산한다.
  
  ```javascript
  console.log(3 - "1"); // 2
  ```

### 3.4. 단항 연산자

- `+`
  
  - 값을 Number타입으로 변환
    
    ```javascript
    var value = "1";
    console.log(typeof value); // string
    console.log(typeof +value); // number
    console.log(typeof Number(value)); // number
    ```

- `-`
  
  - 값의 부호를 바꿈
    
    ```javascript
    var value = "1";
    console.log(-value); // -1
    console.log(3 + -value); // 2
    console.log(value); // 1
    ```
    
    - 연산할 때만 바뀌고 원래 값은 바뀌지 않는다.

### 3.5. 후치, 전치, 논리 NOT 연산자

- 후치`++`
  
  - 형태: value++
  
  - 문장을 수행한 후 값을 자동으로 1증가 시킴

- 전치 `++`
  
  - 형태: ++value
  
  - 값을 자동으로 1증가 시키고 문장을 수행

- 후치 `--`
  
  - 형태: value--
  
  - 문장을 수행한 수 값을 자동으로 1감소 시킴

- 전치 `--`
  
  - 형태: --value
  
  - 값을 자동으로 1감소 시키고 문장을 수행

- `!` 연산자
  
  - 형태: !value
  
  - 표현식 평가 결과를 true, false로 변환한 후 true이면 false, false이면 true
  
  - 원래 값은 바뀌지 않으며 사용할 때만 변환

### 3.6. 유니코드, UTF

- 유니코드
  
  - 세계의 모든 문자를 통합하여 코드화
  
  - 언어, 이모지 등
  
  - 코드 값을 코드 포인트라고 부름
  
  - 0000~FFFF, 10000~1FFFF 값에 문자 매핑

- UTF
  
  - Unicode Transformation Fromat
  
  - 유니코드의 코드 포인트를 매핑하는 방법
  
  - UTF-8은 8비트로 코드 포인트 매핑

### 3.7. 관계연산자

- 관계연산자
  
  - `<`, `>`, `<=`, `>=`
  
  - instanceof 
  
  - in

- `>`
  
  - 양쪽이 number타입일 때
    
    - 왼쪽이 오른쪽보다 크면 true 반환 아니면 false
  
  - string타입일 때
    
    - 한쪽만 string 타입이면 false 반환
      
      ```javascript
      console.log(1 > "A"); // false
      ```
    
    - 양쪽 모두 string 타입이면 유니코드 사전 순서로 비교
      
      ```javascript
      console.log("가" > "나"); // false
      ```

### 3.8. 동등, 부등, 일치, 불일치 연산자

- `==` 동등연산자
  
  - 왼쪽과 오른쪽 값이 같으면 true, 다르면 false
  
  - 값 타입은 비교하지 않음
    
    ```javascript
    console.log(1 == "1"); // true
    ```
    
    비교 대상이 문자:숫자 일 때 문자 타입을 숫자 타입으로 변환하여 비교

- `!=` 부등연산자
  
  - 왼쪽과 오른쪽 값이 다르면 true

- `===` 일치연산자
  
  - 왼쪽과 오른쪽의 값과 타입이 모두 같으면 true
  
  - 값 또는 타입이 다르면 false
  
  ```javascript
  console.log("1" === 1); // false
  ```

### 3.9. 논리연산자

- `||` 
  
  - 표현식의 평가 결과가 하나라도 true이면 true 아니면 false
  
  - 왼쪽 결과가 true이면 오른쪽은 비교하지 않음

- `&&`
  
  - 표현식의 평가 결과가 모두 true이면 true 아니면 false
  
  - 왼쪽 결과가 false이면 오른쪽은 비교하지 않음

### 3.10. 조건연산자

- 표현식 ? 표현식1 : 표현식2

- 표현식이 true이면 표현식1의 결과 반환, false이면 표현식2의 결과 반환

- 3항 연산자라고도 함
  
  ```javascript
  표현식이 true니? true면 요기 : false면 요기 값을 반환
  ```

## 

## 4. 문장(Statement)

### 4.1. if

- 형태
  
  - if(표현식) 문장1
  
  - if(표현식) 문장1 else 문장2

- 조건에 따른 처리
  
  - 먼저 표현식을 평가
  
  - 평가 결과를 true/false로 변환
  
  - true이면 문장 1실행 
  
  - false이면 문장 2실행

### 4.2. while, do-while

- while
  
  - 표현식의 평가 결과가 false가 될 때까지 문장을 반복하여 실행
  
  - 반복이 종료되는 조건이 필요
    
    ```javascript
    var k = 1;
    while(k < 3) {
        console.log(k);
        k++
    };
    // 1
    // 2
    ```

- do-while
  
  - while의 조건이 false가 되기전까지 do 문을 반복적으로 먼저 실행
    
    ```javascript
    var i = 1;
    do {
        console.log("do:", i);
        i++;
    } while (i < 3) {
        console.log("while:", i);
    }
    // do: 0
    // do: 1
    // do: 2
    // while: 3
    ```
    
    일단 do를 해라 while의 조건이 false가 될 때까지 그리고나서 다음 문장을 실행해라

### 4.3. for

- 형태: for(초깃값; 비교; 증감) 문장

- 2번째의 비교표현식의 평가 결과가 true인 동안 문장을 반복 실행
  
  ```javascript
  for (i = 0; i < 2; i++) {
      console.log(i);
  }
  // 0
  // 1
  ```
  
  - 1부터 50까지 짝수 합/홀수 합/총합 구하기
    
    ```javascript
    var oddSum = 0;
    var evenSum = 0;
    var total = 0;
    for (var i = 1; i <= 50; i++) {
        if(i%2 === 0) {
        evenSum += i;
    }else {
        oddSum += i;
    }
        total = evenSum + oddSum;
    }
    console.log("홀수의 합:", oddSum);
    console.log("짝수의 합:", evenSum);
    console.log("총합:", total);
    
    // 홀수의 합: 625
    // 짝수의 합: 650
    // 총합: 1275
    ```

### 4.4 break, continue

- break
  
  - 반복을 종료
    
    ```javascript
    for (var i = 0; i < 5; i++) {
        if(i === 2) {
            console.log("break")
            break
        };
        console.log(i);
    };
    
    // 0
    // 1
    // break
    ```
    
    

- continue
  
  - 반복문의 처음으로 분기
    
    ```javascript
    for (var i = 0; i < 5; i++) {
        if( i === 2 || i === 3){
            continue;
        };
        console.log(i);
    }
            
    // 0
    // 1
    // 4
    ```

### 4.5. switch

- 형태
  
  ```javascript
  switch (표현식){
    case 표현식: 문장리스트opt
    default: 문장리스트opt
  }
  ```

- switch 표현식의 평가 값과 일치하는 case문 수행

- 일치하는 case가 없으면 default 수행
  
  ```javascript
  var i = 3;
  switch(i) {
      case 1:
          console.log("i는 1이다.");
      case 2:
          console.log("i는 2이다.");
      case 3:
          console.log("i는 3이다.");
  }
  // i는 3이다.
  ```
  
  ```javascript
  var i = 0;
  switch(i) {
      case 1:
          console.log("i는 1이다.");
      case 2:
          console.log("i는 2이다.");
      case 3:
          console.log("i는 3이다.");
      default:
          console.log("i는 1도 2도 3도 아니다.");
  }
  // i는 1도 2도 3도 아니다.
  ```
  
  default가 있더라도 break문을 사용하지 않으면 아래와 같은 결과가 나온다
  
  ```javascript
  var i = 0;
  switch(i) {
      case 1:
          console.log("i는 1이다.");
      default:
          console.log("i는 1도 2도 3도 아니다.");
      case 2:
          console.log("i는 2이다.");
      case 3:
          console.log("i는 3이다.");
  }
  
  // i는 1도 2도 3도 아니다.
  // i는 2이다.
  // i는 3이다.
  ```
  
  break문 사용
  
  ```javascript
  var i = 0;
  switch(i) {
      case 1:
          console.log("i는 1이다.");
      default:
          console.log("i는 1도 2도 3도 아니다.");
          break
      case 2:
          console.log("i는 2이다.");
      case 3:
          console.log("i는 3이다.");
  }
  // i는 1도 2도 3도 아니다.
  ```

### 4.6. try-catch, throw

- try-catch
  
  - 형태
    try블록 catch블록

- try문에서 코드의 에러가 발생하면 catch문을 실행한다.
  
  ```javascript
  var value;
  try {
      value = value1
      console.log(value);
  } catch(error) {
      console.log("try문에 에러가 있어요")
  }
  
  // try문에 에러가 있어요
  ```
  
  value1변수가 선언되지 않아서 error 발생
  
  ```javascript
  var value;
  var value1 = 1;
  try {
      value = value1
      console.log(value);
  } catch(error) {
      console.log("try문에 에러가 있어요")
  }
  // 1
  ```
  
  error을 e 또는 err로 사용하는 경우가 보편적이다.

- throw
  
  - 형태: throw 표현식
  
  - 명시적으로 예외를 발생시킴
  
  - 예외가 발생하면 catch 실행
    
    ```javascript
    try {
        throw "예외를 e로 던짐";
        var ignore = "무시";
    } catch(e) {
        console.log(e);
        console.log(ignore);
    }
    // 예외를 e로 던짐
    // undefined
    ```
    
    throw문에서 예외를 발생시키고 try문이 끝고 catch문이 실행 됨, 변수 ignore는 건너뛰게 됨 
